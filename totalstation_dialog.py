# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TotalopenstationDialog
                                 A QGIS plugin
 Total Open Station (TOPS for friends) is a free software program for downloading and processing data from total station devices.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-01
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Enzo Cocca adArte srl; Stefano Costa
        email                : enzo.ccc@gmail.com
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import math
import os
import sys
from datetime import date
import pandas as pd
import subprocess
import platform
import csv
import tempfile
import textwrap as tr
import importlib
import pkgutil
from qgis.PyQt import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import (
    QVBoxLayout,
    QApplication,
    QDialog,
    QMessageBox,
    QFileDialog,
    QLineEdit,
    QWidget,
    QCheckBox,
    QProgressBar,
    QInputDialog,
)
from qgis.PyQt.QtSql import *

from qgis.core import *
from qgis.gui import *
from qgis.utils import iface
from pathlib import Path
from totalopenstation import formats as tops_formats
from totalopenstation import models as tops_models


def find_python():
    if sys.platform != "win32":
        return sys.executable

    for path in sys.path:  # searching sys.path for python executables
        assumed_path = os.path.join(path, "python.exe")
        if os.path.isfile(assumed_path):
            return assumed_path

    raise Exception("Python executable not found")

def path_parse():
    is_windows = sys.platform == "win32" or platform.system().lower() == "windows"
    if is_windows:
        path2parser = Path(
            QgsApplication.qgisSettingsDirPath().replace('/', '\\'))  # check path totalstation parser for
        # windows and replace slash to backslash. It not working if you don't replace
    else:
        path2parser = Path(QgsApplication.qgisSettingsDirPath())
    return path2parser

FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "totalstation_dialog_base.ui")
)


class TotalopenstationDialog(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(TotalopenstationDialog, self).__init__(parent)
        self.setupUi(self)
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.groupBox_coordinate.setHidden(False)
        self.model = QtGui.QStandardItemModel(self)
        self.tableView.setModel(self.model)
        self.toolButton_input.clicked.connect(self.setPathinput)
        self.toolButton_output.clicked.connect(self.setPathoutput)
        self.toolButton_save_raw.clicked.connect(self.setPathsaveraw)
        self.mDockWidget.setHidden(True)
        self.comboBox_model.currentIndexChanged.connect(self.tt)
        self.lineEdit_save_raw.textChanged.connect(self.connect)
        self.pushButton_connect.setEnabled(False)
        self.pushButton_destination.clicked.connect(self.selection_point)
        self.pushButton_origin.clicked.connect(self.selection_origin)
        self.python_exe = find_python()
        self.path2parser = path_parse()
        self.populate_model_combo()



    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def connect(self):

        if str(self.lineEdit_save_raw.text()):

            self.pushButton_connect.setEnabled(True)

        else:
            self.pushButton_connect.setEnabled(False)

    def tt(self):
        current_model = self.comboBox_model.currentText()
        if current_model not in {"custom", "custom_bluetooth"}:

            self.mDockWidget.setHidden(True)
        else:

            self.mDockWidget.show()

    def available_models(self):
        package_path = Path(tops_models.__file__).parent
        return sorted(
            module.name
            for module in pkgutil.iter_modules([str(package_path)])
            if not module.name.startswith("_")
        )

    def populate_model_combo(self):
        detected_models = self.available_models()

        if not detected_models:
            self.textEdit.appendPlainText(
                "No total station models detected in totalopenstation.models"
            )
            return

        previous_model = self.comboBox_model.currentText()
        self.comboBox_model.clear()
        self.comboBox_model.addItems(detected_models)

        if previous_model in detected_models:
            self.comboBox_model.setCurrentText(previous_model)

    def detect_input_format(self, input_path: str):
        """Heuristically detect the correct parser for a raw file.

        The detector instantiates every built-in parser and chooses the one
        that yields the highest number of parsed points. Exceptions from
        parsers are ignored so a single parser failure does not block
        detection.
        """

        try:
            raw_data = Path(input_path).read_text(encoding="ISO-8859-1")
        except Exception as exc:  # noqa: BLE001 - keep generic to log in UI
            self.textEdit.appendPlainText(
                f"Impossibile leggere il file per il rilevamento automatico: {exc}"
            )
            return None

        candidates = []
        for key, parser_data in tops_formats.BUILTIN_INPUT_FORMATS.items():
            module_name, class_name, _ = parser_data
            try:
                module = importlib.import_module(
                    f"totalopenstation.formats.{module_name}"
                )
                parser_cls = getattr(module, class_name)
                parser = parser_cls(raw_data)
                points = parser.points
            except Exception:
                continue

            if points:
                candidates.append((len(points), key))

        if not candidates:
            self.textEdit.appendPlainText(
                "Nessun formato riconosciuto automaticamente: seleziona manualmente"
            )
            return None

        candidates.sort(reverse=True)
        best_match = candidates[0][1]
        return best_match

    def apply_detected_format(self, detected_format):
        if not detected_format:
            return

        index = self.comboBox_format.findText(detected_format)
        if index != -1:
            self.comboBox_format.setCurrentIndex(index)
            self.textEdit.appendPlainText(
                f"Formato rilevato automaticamente: {detected_format}"
            )

    def setPathinput(self):
        s = QgsSettings()
        input_ = QFileDialog.getOpenFileName(self, "Set file name", "", "(*.*)")[0]
        # filename=dbpath.split("/")[-1]
        if input_:

            self.lineEdit_input.setText(input_)
            s.setValue("", input_)
            detected_format = self.detect_input_format(input_)
            self.apply_detected_format(detected_format)

    def setPathoutput(self):
        s = QgsSettings()
        output_ = QFileDialog.getSaveFileName(
            self,
            "Set file name",
            "",
            "(*.{})".format(self.comboBox_format2.currentText()),
        )[0]
        # filename=dbpath.split("/")[-1]
        if output_:

            self.lineEdit_output.setText(output_)
            s.setValue("", output_)

    def setPathsaveraw(self):
        s = QgsSettings()
        output_ = QFileDialog.getSaveFileName(self, "Set file name", "", "(*.tops)")[0]
        # filename=dbpath.split("/")[-1]
        if output_:

            self.lineEdit_save_raw.setText(output_)
            s.setValue("", output_)

    def loadCsv(self, fileName):
        self.tableView.clearSpans()

        with open(fileName, "r") as fileInput:
            for row in csv.reader(fileInput):

                items = [QtGui.QStandardItem(field) for field in row]
                self.model.appendRow(items)

    def delete(self):
        if self.tableView.selectionModel().hasSelection():
            indexes = [
                QPersistentModelIndex(index)
                for index in self.tableView.selectionModel().selectedRows()
            ]
            for index in indexes:
                # print('Deleting row %d...' % index.row())
                self.model.removeRow(index.row())

    def check_port(self):

        p = subprocess.run(
            [self.python_exe, "-m", "serial.tools.list_ports"],
            capture_output=True,
            text=True,
            check=False,
        )

        if p.stderr:
            self.textEdit.appendPlainText(
                "Unable to list serial ports: {}".format(p.stderr.strip())
            )

        return [line for line in p.stdout.splitlines() if line.strip()]

    def listtostr(self):

        return "\n".join(self.check_port())

    def on_pushButton_check_port_pressed(self):
        self.textEdit.appendPlainText("Wait a moment....")
        ports = self.check_port()
        if not ports:
            self.textEdit.appendPlainText("No serial ports found.")
            self.comboBox_port.clear()
            return

        pretty_ports = "\n".join(ports)
        self.textEdit.appendPlainText("Ports found:\n" + pretty_ports)
        self.comboBox_port.clear()
        self.comboBox_port.addItems(ports)

    def convert_csv(self):
        try:
            df = pd.read_csv(str(self.lineEdit_output.text()))
            df[["area_q", "point_name"]] = df["point_name"].str.split("-", expand=True)
            df.to_csv(str(self.lineEdit_output.text()), encoding="utf-8", index=False)
        except:
            pass

    def on_pushButton_export_pressed(self):

        self.delete()
        self.cmd=os.path.join(
            os.sep,
            self.path2parser,
            "python",
            "plugins",
            "totalopenstationToQgis",
            "scripts",
            "totalopenstation-cli-parser.py",
        )
        try:

            if self.comboBox_format2.currentIndex() == 6:# format output shapefile
                direct = os.path.dirname(
                    os.path.abspath(str(self.lineEdit_output.text()))
                )
                filename = Path(self.lineEdit_output.text()).stem
                shp_csv = direct + "/" + filename + ".csv"
                subprocess.run(
                    [
                        self.python_exe,
                        self.cmd,
                        "-i",
                        str(self.lineEdit_input.text()),
                        "-o",
                        shp_csv,
                        "-f",
                        self.comboBox_format.currentText(),
                        "-t",
                        "csv",
                        "--overwrite",
                    ],
                )

                uri = (
                    "file:///"
                    + shp_csv
                    + "?type=csv&xField=x&yField=y&spatialIndex=no&subsetIndex=no&watchFile=no"
                )
                layer1 = QgsVectorLayer(uri, "totalopenstation", "delimitedtext")

                shp_l = direct + "/" + filename + ".shp"
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer1,
                    shp_l,
                    "UTF-8",
                    layer1.crs(),
                    "ESRI Shapefile",
                    layerOptions=["SHPT=POINT"],
                )

                if len(QgsProject.instance().mapLayersByName("TOPS-first_job")) != 0:

                    layer2 = QgsVectorLayer(shp_l, "TOPS-second_job", "ogr")
                else:
                    layer2 = QgsVectorLayer(shp_l, "TOPS-first_job", "ogr")

                QgsProject.instance().addMapLayer(layer2)

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.loadCsv(shp_csv)


            elif self.comboBox_format2.currentIndex() == 0:

                layer = QgsVectorLayer(
                    str(self.lineEdit_output.text()), "totalopenstation", "ogr"
                )

                layer.isValid()

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.warning(
                    self,
                    "Total Open Station luncher",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.progressBar.reset()
                tempfile.mkstemp(suffix=".csv")
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer, "test.csv", "utf-8", driverName="CSV"
                )

                self.loadCsv("test.csv")
            elif self.comboBox_format2.currentIndex() == 1:

                layer = QgsVectorLayer(
                    str(self.lineEdit_output.text()), "totalopenstation", "ogr"
                )

                layer.isValid()

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.warning(
                    self,
                    "Total Open Station luncher",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )
                self.progressBar.reset()
                tempfile.mkstemp(suffix=".csv")
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer, "test.csv", "utf-8", driverName="CSV"
                )
                self.loadCsv("test.csv")

            elif self.comboBox_format2.currentIndex() == 2:

                self.convert_csv()
                uri = (
                    "file:///"
                    + str(self.lineEdit_output.text())
                    + "?type=csv&xField=x&yField=y&spatialIndex=yes&subsetIndex=yes&watchFile=no"
                )
                layer = QgsVectorLayer(
                    uri, "totalopenstation Pyarchinit Quote", "delimitedtext"
                )

                layer.isValid()

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.loadCsv(str(self.lineEdit_output.text()))

                """copy and past from totalstation to pyarchinit"""
                sourceLYR = QgsProject.instance().mapLayersByName(
                    "totalopenstation Pyarchinit Quote"
                )[0]
                destLYR = QgsProject.instance().mapLayersByName(
                    "Quote US disegno"
                )[0]
                # Dialog Box for input "name sito archeologico" to select it...
                ID_Sito = QInputDialog.getText(
                    None, "Sito", "Input Nome del sito archeologico"
                )
                Sito = str(ID_Sito[0])
                ID_M = QInputDialog.getText(
                    None,
                    "Unità di misura",
                    "Input tipo di unità di misura\n (ex: metri)",
                )
                Misura = str(ID_M[0])
                ID_Disegnatore = QInputDialog.getText(
                    None, "Disegnatore", "Input Nome del Disegnatore"
                )
                Disegnatore = str(ID_Disegnatore[0])
                features = []
                if self.checkBox_coord.isChecked():
                    # ID_X = QInputDialog.getText(None, 'X', 'Input coord X')
                    # x = float(ID_X[0])
                    # ID_Y = QInputDialog.getText(None, 'Y', 'Input Coord Y')
                    # y = float(ID_Y[0])
                    ID_Z = QInputDialog.getText(None, "Z", "Input Elevation")
                    q = float(ID_Z[0])

                    # expression1 = QgsExpression('x($geometry)+{}'.format(x))
                    # expression2 = QgsExpression('y($geometry)+{}'.format(y))
                    # context = QgsExpressionContext()
                    # scope = QgsExpressionContextScope()
                    # context.appendScope(scope)

                    for feature in sourceLYR.getFeatures():
                        # scope.setFeature(feature)
                        # a = expression1.evaluate(context)
                        # b = expression2.evaluate(context)
                        # if a and b:
                        features.append(feature)
                        feature.setAttribute("sito_q", Sito)
                        feature.setAttribute("unita_misu_q", Misura)
                        feature.setAttribute("x", str(date.today().isoformat()))
                        feature.setAttribute("y", Disegnatore)
                        attr_Q = feature.attributes()[5]
                        p = q + float(attr_Q)

                        feature.setAttribute("quota_q", p)

                        # geom = feature.geometry()
                        # geom.get().setX(a)
                        # geom.get().setY(b)

                        # feature.setGeometry(geom)
                        sourceLYR.updateFeature(feature)
                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()
                else:
                    for feature in sourceLYR.getFeatures():

                        features.append(feature)
                        feature.setAttribute("sito_q", Sito)
                        feature.setAttribute("unita_misu_q", Misura)
                        feature.setAttribute("x", str(date.today().isoformat()))
                        feature.setAttribute("y", Disegnatore)

                        sourceLYR.updateFeature(feature)
                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()

                QgsProject.instance().removeMapLayer(sourceLYR)
                ###########finish############################################

            elif self.comboBox_format2.currentIndex() == 3:

                uri = (
                    "file:///"
                    + str(self.lineEdit_output.text())
                    + "?type=csv&xField=x&yField=y&spatialIndex=yes&subsetIndex=yes&watchFile=no"
                )
                layer = QgsVectorLayer(
                    uri,
                    "totalopenstation Pyarchinit riferimento",
                    "delimitedtext",
                )

                layer.isValid()

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.loadCsv(str(self.lineEdit_output.text()))

                """copy and past from totalstation to pyarchinit"""
                sourceLYR = QgsProject.instance().mapLayersByName(
                    "totalopenstation Pyarchinit riferimento"
                )[0]
                destLYR = QgsProject.instance().mapLayersByName(
                    "Punti di riferimento"
                )[0]

                # Dialog Box for input "name sito archeologico" to select it...
                ID_Sito = QInputDialog.getText(
                    None, "Sito", "Input Nome del sito archeologico"
                )
                Sito = str(ID_Sito[0])
                features = []
                if self.checkBox_coord.isChecked():
                    # ID_X = QInputDialog.getText(None, 'X', 'Input coord X')
                    # x = float(ID_X[0])
                    # ID_Y = QInputDialog.getText(None, 'Y', 'Input Coord Y')
                    # y = float(ID_Y[0])
                    ID_Z = QInputDialog.getText(None, "Z", "Input Elevation")
                    q = float(ID_Z[0])

                    # expression1 = QgsExpression('x($geometry)+{}'.format(x))
                    # expression2 = QgsExpression('y($geometry)+{}'.format(y))
                    # context = QgsExpressionContext()
                    # scope = QgsExpressionContextScope()
                    # context.appendScope(scope)

                    for feature in sourceLYR.getFeatures():
                        # scope.setFeature(feature)
                        # a = expression1.evaluate(context)
                        # b = expression2.evaluate(context)
                        # if a and b:
                        features.append(feature)

                        feature.setAttribute("sito", Sito)
                        attr_Q = feature.attributes()[4]
                        p = q + float(attr_Q)

                        feature.setAttribute("quota", p)

                        # geom = feature.geometry()
                        # geom.get().setX(a)
                        # geom.get().setY(b)

                        # feature.setGeometry(geom)
                        sourceLYR.updateFeature(feature)

                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()

                else:

                    features = []
                    for feature in sourceLYR.getFeatures():
                        features.append(feature)
                        feature.setAttribute("sito", Sito)
                        sourceLYR.updateFeature(feature)

                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()

                QgsProject.instance().removeMapLayer(sourceLYR)
                ###########finish############################################

            elif self.comboBox_format2.currentIndex() == 4:

                uri = (
                    "file:///"
                    + str(self.lineEdit_output.text())
                    + "?type=csv&xField=x&yField=y&spatialIndex=yes&subsetIndex=yes&watchFile=no"
                )
                layer = QgsVectorLayer(
                    uri, "totalopenstation Pyarchinit Sample", "delimitedtext"
                )

                layer.isValid()

                QgsProject.instance().addMapLayer(layer)

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.loadCsv(str(self.lineEdit_output.text()))

                """copy and past from totalstation to pyarchinit"""
                sourceLYR = QgsProject.instance().mapLayersByName(
                    "totalopenstation Pyarchinit Sample"
                )[0]
                destLYR = QgsProject.instance().mapLayersByName(
                    "Punti di campionatura"
                )[0]
                # Dialog Box for input "name sito archeologico" to select it...
                ID_Sito = QInputDialog.getText(
                    None, "Sito", "Input Nome del sito archeologico"
                )
                Sito = str(ID_Sito[0])
                # a=[]
                if self.checkBox_coord.isChecked():
                    # ID_X = QInputDialog.getText(None, 'X', 'Input coord X')
                    # x = float(ID_X[0])
                    # ID_Y = QInputDialog.getText(None, 'Y', 'Input Coord Y')
                    # y = float(ID_Y[0])

                    features = []
                    # expression1 = QgsExpression('x($geometry)+{}'.format(x))
                    # expression2 = QgsExpression('y($geometry)+{}'.format(y))
                    # context = QgsExpressionContext()
                    # scope = QgsExpressionContextScope()
                    # context.appendScope(scope)

                    for feature in sourceLYR.getFeatures():
                        # scope.setFeature(feature)
                        # a = expression1.evaluate(context)
                        # b = expression2.evaluate(context)
                        # if a and b:
                        features.append(feature)

                        feature.setAttribute("sito", Sito)
                        # geom = feature.geometry()
                        # geom.get().setX(a)
                        # geom.get().setY(b)

                        # feature.setGeometry(geom)
                        sourceLYR.updateFeature(feature)

                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()

                else:

                    features = []
                    for feature in sourceLYR.getFeatures():
                        features.append(feature)
                        feature.setAttribute("sito", Sito)
                        sourceLYR.updateFeature(feature)

                    destLYR.startEditing()
                    data_provider = destLYR.dataProvider()
                    data_provider.addFeatures(features)
                    iface.mapCanvas().zoomToSelected()
                    destLYR.commitChanges()

                QgsProject.instance().removeMapLayer(sourceLYR)
                ###########finish############################################

            elif self.comboBox_format2.currentIndex() == 5:
                uri = (
                    "file:///"
                    + str(self.lineEdit_output.text())
                    + "?type=csv&xField=x&yField=y&spatialIndex=no&subsetIndex=no&watchFile=no"
                )
                layer1 = QgsVectorLayer(
                    uri, "totalopenstation", "delimitedtext"
                )

                # layer.isValid()

                QgsProject.instance().addMapLayer(layer1)

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "data loaded into panel Layer",
                    QMessageBox.Ok,
                )

                self.loadCsv(str(self.lineEdit_output.text()))


            else:

                QMessageBox.warning(
                    self,
                    "Total Open Station",
                    "Questo formato non verrà importato in QGIS ma solamente salvato",
                    QMessageBox.Ok,
                )

        except Exception as e:

            QMessageBox.warning(
                self, "Total Open Station", "Error:\n" + str(e), QMessageBox.Ok
            )


    def rmvLyr(lyrname):
        qinst = QgsProject.instance()
        qinst.removeMapLayer(qinst.mapLayersByName(lyrname)[0].id())

    def check_layer(self):

        if not bool(
            len(QgsProject.instance().mapLayersByName("TOPS-second_job"))
        ) or len(QgsProject.instance().mapLayersByName("TOPS-first_job")):

            self.pushButton_rt.setHidden(True)
        else:
            QMessageBox.warning(
                self,
                "Total Open Station",
                "Ricordati che il file da rototraslare deve essere nominato TOPS-second_job",
                QMessageBox.Ok,
            )
            self.pushButton_rt.setHidden(False)

    def selection_point(self):
        # self.check_layer()
        try:  # attivo il layer che voglio traslare

            # layer su cui scegliere ilpunto per traslare
            b = QgsProject.instance().mapLayersByName("TOPS-first_job")[0]

            # avvio editing
            # a.startEditing()

            # seleziono il punto dalla poligonale su cui devo traslare
            # QMessageBox.information(self, 'TotalopeStation', 'Select the Point where you want translate from the first job in tha map canvas')

            selection = b.selectedFeatures()
            if not selection:
                raise ValueError(
                    "Seleziona almeno un punto in 'TOPS-first_job' prima di procedere"
                )

            # estraggo le coordinate x y
            pt = QgsPointXY(selection[0]["x"], selection[0]["y"])
            print(pt)
            self.lineEdit_x_destination.setText(str(pt[0]))
            self.lineEdit_x_destination.text()
            self.lineEdit_y_destination.setText(str(pt[1]))
            self.lineEdit_y_destination.text()

        except Exception as e:
            QMessageBox.information(self, "TotalopenStation", str(e))

    def selection_origin(self):
        b = QgsProject.instance().mapLayersByName("TOPS-first_job")[0]
        selection_or = b.selectedFeatures()
        if not selection_or:
            QMessageBox.information(
                self,
                "TotalopenStation",
                "Seleziona almeno un punto in 'TOPS-first_job' prima di impostare l'origine",
            )
            return
        pt2 = QgsPointXY(selection_or[0]["x"], selection_or[0]["y"])
        print(pt2)
        self.lineEdit_x_origin.setText(str(pt2[0]))
        self.lineEdit_x_origin.text()
        self.lineEdit_y_origin.setText(str(pt2[1]))
        self.lineEdit_y_origin.text()

    def on_pushButton_crs_pressed(self):
        if (
            QgsCoordinateReferenceSystem()
            .fromProj4(
                "+proj=tmerc +ellps=WGS84 +datum=WGS84 +units=m +no_defs +lon_0=0 +x_0=0 +y_0=0 +k_0=0.996"
            )
            .isValid()
            == False
        ):
            crs = QgsCoordinateReferenceSystem()
            # if crs.toProj4()=="+proj=tmerc +ellps=WGS84 +datum=WGS84 +units=m +no_defs +lon_0=0 +x_0=0 +y_0=0 +k_0=0.996":
            # crs.createFromSrsId(100000)
            crs.createFromProj4(
                "+proj=tmerc +ellps=WGS84 +datum=WGS84 +units=m +no_defs +lon_0=0 +x_0=0 +y_0=0 +k_0=0.996"
            )
            crs.saveAsUserCrs("UCS")
            QgsProject.instance().setCrs(crs)
        else:
            crs = QgsCoordinateReferenceSystem().fromProj4(
                "+proj=tmerc +ellps=WGS84 +datum=WGS84 +units=m +no_defs +lon_0=0 +x_0=0 +y_0=0 +k_0=0.996"
            )
            QgsProject.instance().setCrs(crs)

    def on_pushButton_rt_pressed(self):
        QMessageBox.information(
            self,
            "TotalopenStation",
            "Select the Point where you want translate and than the origin point of your poligonal from the first job in tha map canvas",
        )

        # self.selection_point()
        # self.check_layer()
        # attivo il layer che voglio traslare
        crs = QgsCoordinateReferenceSystem().fromProj4(
            "+proj=tmerc +ellps=WGS84 +datum=WGS84 +units=m +no_defs +lon_0=0 +x_0=0 +y_0=0 +k_0=0.996"
        )
        second_job_layers = QgsProject.instance().mapLayersByName("TOPS-second_job")
        first_job_layers = QgsProject.instance().mapLayersByName("TOPS-first_job")

        if not second_job_layers:
            QMessageBox.warning(
                self,
                "TotalOpenStation",
                "Nessun layer 'TOPS-second_job' trovato da rototraslare",
                QMessageBox.Ok,
            )
            return
        if not first_job_layers:
            QMessageBox.warning(
                self,
                "TotalOpenStation",
                "Nessun layer di riferimento 'TOPS-first_job' trovato",
                QMessageBox.Ok,
            )
            return

        a = second_job_layers[0]
        b = first_job_layers[0]
        a.setCrs(crs)
        b.setCrs(crs)

        try:
            dest_x = float(self.lineEdit_x_destination.text())
            dest_y = float(self.lineEdit_y_destination.text())
            origin_x = float(self.lineEdit_x_origin.text())
            origin_y = float(self.lineEdit_y_origin.text())
        except ValueError:
            QMessageBox.warning(
                self,
                "TotalOpenStation",
                "Inserisci coordinate numeriche valide prima di eseguire la rototraslazione",
                QMessageBox.Ok,
            )
            return

        dx = dest_x - origin_x
        dy = dest_y - origin_y
        rotation_angle = math.degrees(math.atan2(dy, dx))

        # preparo il context
        context = QgsExpressionContext()
        scope = QgsExpressionContextScope()
        context.appendScope(scope)

        translate_expr = QgsExpression(f"translate($geometry,{dx},{dy})")
        rotate_expr = QgsExpression(
            f"rotate($geometry,{rotation_angle},make_point({dest_x},{dest_y}))"
        )
        x_expr = QgsExpression("$x")
        y_expr = QgsExpression("$y")

        if not a.isEditable():
            a.startEditing()

        a.beginEditCommand("Rototraslazione su punti noti")
        try:
            for feature in a.getFeatures():
                QCoreApplication.processEvents()
                scope.setFeature(feature)
                translated_geom = translate_expr.evaluate(context)
                if isinstance(translated_geom, QgsGeometry):
                    feature.setGeometry(translated_geom)
                    a.updateFeature(feature)

            for feature in a.getFeatures():
                QCoreApplication.processEvents()
                scope.setFeature(feature)
                rotated_geom = rotate_expr.evaluate(context)
                if isinstance(rotated_geom, QgsGeometry):
                    feature.setGeometry(rotated_geom)
                    a.updateFeature(feature)

            x_index = a.fields().indexOf("x")
            y_index = a.fields().indexOf("y")
            for feature in a.getFeatures():
                QCoreApplication.processEvents()
                scope.setFeature(feature)
                if x_index != -1:
                    feature.setAttribute(x_index, x_expr.evaluate(context))
                if y_index != -1:
                    feature.setAttribute(y_index, y_expr.evaluate(context))
                a.updateFeature(feature)
        except Exception as exc:
            a.destroyEditCommand()
            QMessageBox.warning(
                self,
                "TotalOpenStation",
                f"Errore durante la rototraslazione:\n{exc}",
                QMessageBox.Ok,
            )
            a.rollBack()
            return
        else:
            a.endEditCommand()

        self.canvas.refresh()
        value = QMessageBox.information(
            self,
            "TotalOpenStation",
            "Rototraslazione completata, clicca OK per salvare o Cancel per annullare",
            QMessageBox.Ok | QMessageBox.Cancel,
        )
        if value == QMessageBox.Ok:
            a.commitChanges()
        else:
            a.rollBack()
            self.canvas.refresh()

    def launch_commit(self, msg):
        if msg == QMessageBox.Ok:
            self.on_pushButton_export_matrix_pressed()
        else:
            pass

    def on_pushButton_connect_pressed(self):
        self.textEdit.clear()
        self.cmd = os.path.join(
            os.sep,
            self.path2parser,
            "python",
            "plugins",
            "totalopenstationToQgis",
            "scripts",
            "totalopenstation-cli-connector.py",
        )
        try:
            subprocess.run(
                [
                    self.python_exe,
                    self.cmd,
                    "-m",
                    self.comboBox_model.currentText(),
                    "-p",
                    self.comboBox_port.currentText(),
                    "-o",
                    str(self.lineEdit_save_raw.text()),
                ],
            )

        except Exception as e:
            if self.comboBox_port.currentText() == "":
                self.textEdit.appendPlainText("Insert port please!")

            self.textEdit.appendPlainText("Connection falied!")

        else:
            self.textEdit.appendPlainText("Connection OK.................!\n\n")
            self.textEdit.appendPlainText(
                "Start dowload data.................!\n\n"
            )
            # s = io.StringIO()
            # for i in tqdm(range(3), file=s):
            # sleep(.1)
            # self.textEdit.appendPlainText(s.getvalue())

            self.textEdit.appendPlainText("Dowload finished.................!\n\n")
            self.textEdit.appendPlainText("Result:\n")
            r = open(str(self.lineEdit_save_raw.text()), "r")
            lines = r.read().split(",")
            self.textEdit.appendPlainText(str(lines))
